#version 430

struct Sphere {
  vec3 center;
  float radius;
};

struct Material {
  vec3 albedo;
  vec3 emission;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D image;

layout(std430, binding = 1) readonly buffer sphereBuffer
{
  Sphere spheres[];
};

uniform int u_frames;
uniform int u_samples;
uniform int u_max_bounce;

uniform vec3 u_camera_target;
uniform vec3 u_camera_position;

struct Ray {
  vec3 origin;
  vec3 direction;
};

struct HitInfo {
  float t;
  vec3 point;
  vec3 normal;
};

bool intersect(Ray ray, Sphere sphere, float min_t, float max_t, inout HitInfo info) 
{
    vec3 m = ray.origin - sphere.center;
    float b = dot(m, ray.direction);
    float c = dot(m, m) - sphere.radius * sphere.radius;
    
    if( 0.0 < c && 0.0 < b ) {
        return false;
    }
    
    float discr = b * b - c;
    if (discr < 0.0 ) {
        return false;
    }
    
    float t = -b - sqrt(discr);
    if (t < 0.0) {
        t = -b + sqrt(discr);
    }
    
    if (min_t < t && t < max_t) {
        info.t = t;
        info.point = ray.origin + ray.direction * t;
        info.normal = (info.point - sphere.center) / sphere.radius;
        return true;
    } else {
        return false;
    }
}

int find_collision(Ray ray, inout HitInfo closest_hit)
{
  float min_t = 0.0;
  float max_t = 10000.0;
  int closest_sphere = -1;

  for (int i = 0; i < spheres.length(); i++)
  {
    HitInfo hit;
    if (intersect(ray, spheres[i], min_t, max_t, hit))
    {
      if (hit.t < max_t)
      {
        closest_hit = hit;
        max_t = hit.t;
        closest_sphere = i;
      }
    }
  }

  return closest_sphere;
}

vec3 test_trace(Ray ray)
{
    HitInfo hit;
    if(find_collision(ray, hit))
    {
      return vec3(1);
    } else {
      return vec3(0,0,1);
    }
}

vec3 trace_path(Ray ray) 
{
  vec3 albedo = vec3(0.75, 0.25, 0);
  vec3 emission = vec3(1);

  vec3 radiance = vec3(0);
  vec3 throughput = vec3(1);

  for (int bounce = 0; bounce < u_max_bounce; bounce++)
  {

    HitInfo hit;

    int i = find_collision(ray, hit);
    if (i == -1) {
      break;
    }

    radiance += (emission * throughput);
    throughput *= (albedo); 
  }

  return radiance;
}

void main() 
{
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  ivec2 image_size = imageSize(image);

  vec2 frag_coord = vec2(pixel_coords);
  vec2 resolution = vec2(image_size);

  vec4 pixel = imageLoad(image, pixel_coords);
  vec3 previous = pixel.rgb;
  
  //vec2 uv = vec2(pixel_coords) / vec2(image_size);
  vec2 uv = (frag_coord.xy - 0.5 * resolution.xy) / resolution.y;

  Ray ray = Ray(vec3(0.0), normalize(vec3(uv.x, uv.y, 1.0)));  

#if 0
  int tmp = int(u_frames) % int(1000);
  vec3 col = vec3(uv.x, uv.y, float(tmp) / float(1000));
  pixel = vec4(col, 1);
#endif

#if 1
  vec3 color = vec3(0);

  for (int s = 0; s < u_samples; s++)
  {
    color += trace_path(ray);
  }

  color /= float(u_samples);

  vec3 color_sum = previous * float(u_frames);
  vec3 final_color = (color + color_sum) / (u_frames + 1);
  pixel = vec4(final_color, 1);
#endif

  imageStore(image, pixel_coords, pixel);
}