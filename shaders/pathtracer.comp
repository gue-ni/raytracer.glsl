#version 430

struct Sphere {
  vec3 center;
  float radius;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D image;

layout(std430, binding = 1) readonly buffer sphereBuffer
{
  Sphere spheres[];
};

uniform int u_frames;
uniform int u_samples;
uniform int u_max_depth;

uniform vec3 u_camera_target;
uniform vec3 u_camera_position;

struct Ray {
  vec3 origin;
  vec3 direction;
};

struct HitInfo {
  float t;
  vec3 point;
  vec3 normal;
};

bool intersect(Ray ray, Sphere sphere, float min_t, float max_t, inout HitInfo info) 
{
    vec3 m = ray.origin - sphere.center;
    float b = dot(m, ray.direction);
    float c = dot(m, m) - sphere.radius * sphere.radius;
    
    if( 0.0 < c && 0.0 < b ) {
        return false;
    }
    
    float discr = b * b - c;
    if (discr < 0.0 ) {
        return false;
    }
    
    float t = -b - sqrt(discr);
    if (t < 0.0) {
        t = -b + sqrt(discr);
    }
    
    if (min_t < t && t < max_t) {
        info.t = t;
        info.point = ray.origin + ray.direction * t;
        info.normal = (info.point - sphere.center) / sphere.radius;
        return true;
    } else {
        return false;
    }
}

int find_collision(Ray ray, inout HitInfo closest_hit)
{
  float min_t = 0.0;
  float max_t = 10000.0;
  int closest_sphere = -1;

  for (int i = 0; i < spheres.length(); i++)
  {
    HitInfo hit;
    if (intersect(ray, spheres[i], min_t, max_t, hit))
    {
      if (hit.t < max_t)
      {
        closest_hit = hit;
        max_t = hit.t;
        closest_sphere = i;
      }
    }
  }

  return closest_sphere;
}

vec3 trace_path(Ray ray) 
{
  // TODO




  return vec3(0);
}

void main() 
{
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  ivec2 image_size = imageSize(image);

  vec4 pixel = imageLoad(image, pixel_coords);
  vec3 previous = pixel.rgb;
  
  vec2 uv = vec2(pixel_coords) / vec2(image_size);

#if 1
  int tmp = int(u_frames) % int(1000);
  vec3 col = vec3(uv.x, uv.y, float(tmp) / float(1000));
  pixel = vec4(col, 1);
#endif

#if 0
  vec3 color = vec3(0);

  for (int sample = 0; sample < u_samples; sample++)
  {
    color += trace_path();
  }

  color /= float(u_samples);

  vec3 color_sum = previous * float(u_frames);
  vec3 final_color = (color + color_sum) / (u_frames + 1);
#endif
  
  imageStore(image, pixel_coords, pixel);
}